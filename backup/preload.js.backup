// public/preload.js - VERS√ÉO EXPANDIDA COM APIs DE CONECTIVIDADE

const { contextBridge, ipcRenderer } = require('electron');

contextBridge.exposeInMainWorld('api', {
    // APIs de conex√£o existentes
    connection: {
        connect: (serverInfo) => ipcRenderer.send('start-connection', serverInfo),
    },

    onConnectionStatus: (callback) => {
        ipcRenderer.on('connection-status-update', (event, ...args) => callback(...args));
    },

    storage: {
        get: (key) => ipcRenderer.invoke('get-data', key),
        set: (key, value) => ipcRenderer.send('set-data', key, value),
    },

    // ==========================
    // NOVAS APIs DE CONECTIVIDADE
    // ==========================
    connectivity: {
        /**
         * Testa conectividade de um servidor espec√≠fico
         * @param {Object} serverInfo - Informa√ß√µes do servidor
         * @returns {Promise<Object>} - Resultado do teste
         */
        testServer: (serverInfo) => {
            return ipcRenderer.invoke('connectivity-test-server', serverInfo);
        },

        /**
         * Testa conectividade de m√∫ltiplos servidores
         * @param {Array} servers - Array de servidores
         * @returns {Promise<Array>} - Array de resultados
         */
        testMultipleServers: (servers) => {
            return ipcRenderer.invoke('connectivity-test-multiple', servers);
        },

        /**
         * Inicia monitoramento cont√≠nuo de um servidor
         * @param {Object} serverInfo - Informa√ß√µes do servidor
         * @param {number} interval - Intervalo em ms (padr√£o: 30000)
         */
        startMonitoring: (serverInfo, interval = 30000) => {
            ipcRenderer.send('connectivity-start-monitoring', serverInfo, interval);
        },

        /**
         * Para monitoramento de um servidor
         * @param {string} serverKey - Chave identificadora do servidor
         */
        stopMonitoring: (serverKey) => {
            ipcRenderer.send('connectivity-stop-monitoring', serverKey);
        },

        /**
         * Para todo o monitoramento
         */
        stopAllMonitoring: () => {
            ipcRenderer.send('connectivity-stop-all-monitoring');
        },

        /**
         * Limpa cache de resultados
         */
        clearCache: () => {
            ipcRenderer.send('connectivity-clear-cache');
        },

        /**
         * Obt√©m estat√≠sticas do sistema de conectividade
         * @returns {Promise<Object>} - Estat√≠sticas
         */
        getStats: () => {
            return ipcRenderer.invoke('connectivity-get-stats');
        }
    },

    // ==========================
    // EVENT LISTENERS DE CONECTIVIDADE
    // ==========================

    /**
     * Escuta atualiza√ß√µes de status de conectividade
     * @param {Function} callback - Callback(serverKey, connectivityResult)
     */
    onConnectivityUpdate: (callback) => {
        ipcRenderer.on('connectivity-status-update', (event, serverKey, result) => {
            callback(serverKey, result);
        });
    },

    /**
     * Escuta in√≠cio de testes de conectividade
     * @param {Function} callback - Callback(serverKey, serverInfo)
     */
    onConnectivityTestStart: (callback) => {
        ipcRenderer.on('connectivity-test-start', (event, serverKey, serverInfo) => {
            callback(serverKey, serverInfo);
        });
    },

    /**
     * Escuta conclus√£o de testes de conectividade
     * @param {Function} callback - Callback(serverKey, result)
     */
    onConnectivityTestComplete: (callback) => {
        ipcRenderer.on('connectivity-test-complete', (event, serverKey, result) => {
            callback(serverKey, result);
        });
    },

    /**
     * Escuta erros de conectividade
     * @param {Function} callback - Callback(serverKey, error)
     */
    onConnectivityError: (callback) => {
        ipcRenderer.on('connectivity-error', (event, serverKey, error) => {
            callback(serverKey, error);
        });
    },

    /**
     * Escuta mudan√ßas no monitoramento cont√≠nuo
     * @param {Function} callback - Callback(action, serverKey, data)
     */
    onMonitoringChange: (callback) => {
        ipcRenderer.on('connectivity-monitoring-change', (event, action, serverKey, data) => {
            callback(action, serverKey, data);
        });
    },

    // ==========================
    // UTILIT√ÅRIOS DE CONECTIVIDADE
    // ==========================
    connectivityUtils: {
        /**
         * Valida se um endere√ßo IP √© v√°lido
         * @param {string} ip - Endere√ßo IP
         * @returns {boolean} - True se v√°lido
         */
        isValidIP: (ip) => {
            const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
            return ipRegex.test(ip);
        },

        /**
         * Valida se uma porta √© v√°lida
         * @param {number|string} port - Porta
         * @returns {boolean} - True se v√°lida
         */
        isValidPort: (port) => {
            const portNum = parseInt(port, 10);
            return !isNaN(portNum) && portNum >= 1 && portNum <= 65535;
        },

        /**
         * Gera chave √∫nica para um servidor
         * @param {Object} serverInfo - Informa√ß√µes do servidor
         * @returns {string} - Chave √∫nica
         */
        generateServerKey: (serverInfo) => {
            const port = serverInfo.port || (serverInfo.protocol === 'rdp' ? 3389 : 22);
            return `${serverInfo.ipAddress}:${port}`;
        },

        /**
         * Formata tempo em milissegundos para string leg√≠vel
         * @param {number} ms - Tempo em milissegundos
         * @returns {string} - Tempo formatado
         */
        formatTime: (ms) => {
            if (ms < 1000) return `${ms}ms`;
            return `${(ms / 1000).toFixed(1)}s`;
        },

        /**
         * Formata lat√™ncia para exibi√ß√£o
         * @param {number} latency - Lat√™ncia em ms
         * @returns {Object} - {text, color, icon}
         */
        formatLatency: (latency) => {
            if (!latency || latency < 0) {
                return { text: 'N/A', color: '#666', icon: '‚ùì' };
            }

            if (latency < 50) {
                return { text: `${latency}ms`, color: '#00ff00', icon: 'üü¢' };
            } else if (latency < 150) {
                return { text: `${latency}ms`, color: '#ffaa00', icon: 'üü°' };
            } else {
                return { text: `${latency}ms`, color: '#ff6600', icon: 'üü†' };
            }
        },

        /**
         * Converte status de conectividade em display info
         * @param {string} status - Status (online, offline, partial, etc)
         * @returns {Object} - {icon, color, text, description}
         */
        getStatusDisplayInfo: (status) => {
            const statusMap = {
                'unknown': { 
                    icon: '‚ùì', 
                    color: '#666', 
                    text: 'Desconhecido', 
                    description: 'Status n√£o testado ainda' 
                },
                'testing': { 
                    icon: 'üîÑ', 
                    color: '#ff9500', 
                    text: 'Testando...', 
                    description: 'Teste de conectividade em andamento' 
                },
                'online': { 
                    icon: '‚úÖ', 
                    color: '#00ff00', 
                    text: 'Online', 
                    description: 'Servidor acess√≠vel e porta aberta' 
                },
                'offline': { 
                    icon: '‚ùå', 
                    color: '#ff0000', 
                    text: 'Offline', 
                    description: 'Servidor n√£o responde' 
                },
                'partial': { 
                    icon: '‚ö†Ô∏è', 
                    color: '#ffaa00', 
                    text: 'Parcial', 
                    description: 'Host responde mas porta inacess√≠vel' 
                },
                'error': { 
                    icon: 'üí•', 
                    color: '#cc0000', 
                    text: 'Erro', 
                    description: 'Erro durante teste de conectividade' 
                }
            };

            return statusMap[status] || statusMap['unknown'];
        }
    },

    // ==========================
    // REMO√á√ÉO DE EVENT LISTENERS
    // ==========================
    removeConnectivityListeners: () => {
        ipcRenderer.removeAllListeners('connectivity-status-update');
        ipcRenderer.removeAllListeners('connectivity-test-start');
        ipcRenderer.removeAllListeners('connectivity-test-complete');
        ipcRenderer.removeAllListeners('connectivity-error');
        ipcRenderer.removeAllListeners('connectivity-monitoring-change');
    }
});